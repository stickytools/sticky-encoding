///
///  BinaryEncodingSingleValueContainerNegativeTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/23/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import StickyEncoding

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================

///
/// Negative tests for  single value containers.
///
class BinaryEncodingSingleValueContainerNegativeTests: XCTestCase {

    // MARK: - `Bool` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Bool` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfBool() {
        _testDecodeValueNotFound(input: Optional<Int>.none, expected: (Bool.self, Bool.self, [], "Expected Bool value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Bool` value that was encoded as an `Int` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfBool() {
        _testDecodeTypeMismatch(input: Int(64), expected: (Bool.self, Bool.self, [], "Expected to decode Bool but found Int instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Bool` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfBoolWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (Bool.self, Bool.self, [], "Expected to decode Bool but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfInt() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (Int.self, Int.self, [], "Expected Int value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfInt() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (Int.self, Int.self, [], "Expected to decode Int but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfIntWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int.self, Int.self, [], "Expected to decode Int but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int8` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int8` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfInt8() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (Int8.self, Int8.self, [], "Expected Int8 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int8` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfInt8() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (Int8.self, Int8.self, [], "Expected to decode Int8 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int8` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt8WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int8.self, Int8.self, [], "Expected to decode Int8 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int16` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int16` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfInt16() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (Int16.self, Int16.self, [], "Expected Int16 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int16` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfInt16() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (Int16.self, Int16.self, [], "Expected to decode Int16 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int16` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt16WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int16.self, Int16.self, [], "Expected to decode Int16 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int32` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int32` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfInt32() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (Int32.self, Int32.self, [], "Expected Int32 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int32` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfInt32() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (Int32.self, Int32.self, [], "Expected to decode Int32 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int32` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt32WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int32.self, Int32.self, [], "Expected to decode Int32 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int64` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int64` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfInt64() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (Int64.self, Int64.self, [], "Expected Int64 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int64` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfInt64() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (Int64.self, Int64.self, [], "Expected to decode Int64 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int64` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt64WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int64.self, Int64.self, [], "Expected to decode Int64 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfUInt() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (UInt.self, UInt.self, [], "Expected UInt value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfUInt() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (UInt.self, UInt.self, [], "Expected to decode UInt but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUIntWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt.self, UInt.self, [], "Expected to decode UInt but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt8` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt8` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfUInt8() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (UInt8.self, UInt8.self, [], "Expected UInt8 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt8` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfUInt8() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (UInt8.self, UInt8.self, [], "Expected to decode UInt8 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt8` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt8WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt8.self, UInt8.self, [], "Expected to decode UInt8 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt16` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt16` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfUInt16() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (UInt16.self, UInt16.self, [], "Expected UInt16 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt16` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfUInt16() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (UInt16.self, UInt16.self, [], "Expected to decode UInt16 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt16` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt16WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt16.self, UInt16.self, [], "Expected to decode UInt16 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt32` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt32` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfUInt32() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (UInt32.self, UInt32.self, [], "Expected UInt32 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt32` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfUInt32() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (UInt32.self, UInt32.self, [], "Expected to decode UInt32 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt32` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt32WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt32.self, UInt32.self, [], "Expected to decode UInt32 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt64` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt64` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfUInt64() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (UInt64.self, UInt64.self, [], "Expected UInt64 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt64` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfUInt64() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (UInt64.self, UInt64.self, [], "Expected to decode UInt64 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt64` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt64WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt64.self, UInt64.self, [], "Expected to decode UInt64 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Float` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Float` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfFloat() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (Float.self, Float.self, [], "Expected Float value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Float` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfFloat() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (Float.self, Float.self, [], "Expected to decode Float but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Float` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfFloatWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Float
            init(value: Float) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32.0), expected: (Float.self, Float.self, [], "Expected to decode Float but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Double` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Double` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfDouble() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (Double.self, Double.self, [], "Expected Double value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Double` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfDouble() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (Double.self, Double.self, [], "Expected to decode Double but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Double` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfDoubleWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Double
            init(value: Double) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32.0), expected: (Double.self, Double.self, [], "Expected to decode Double but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `String` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `String` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfString() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (String.self, String.self, [], "Expected String value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `String` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfString() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (String.self, String.self, [], "Expected to decode String but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `String` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfStringWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: "Test String"), expected: (String.self, String.self, [], "Expected to decode String but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `CodableType` Tests

    ///
    /// Note: Currently codable types using a SingleValueDecodingContainer have different error messages and type that single values because of the nature of the encoding.
    ///

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `CodableType` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfCodableType() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (CodableType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [], "Expected KeyedDecodingContainer<CodingKeys> value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfCodableType() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (CodableType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found SingleValueDecodingContainer instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value at the root-level and finds a container other that a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfCodableTypeWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: CodableType(32)), expected: (CodableType.self, Int.self, [CodableType.CodingKeys.value], "Expected to decode Int but found KeyedDecodingContainer<CodingKeys> instead."))
    }
}
