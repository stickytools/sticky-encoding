///
///  BinaryEncodingKeyedContainerNegativeTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/23/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import StickyEncoding


/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================
%{
variants = [
    ("Int",  "64",   "Bool", "true"),
    ("Bool", "true", "Int",   "32"),
    ("Bool", "true", "Int8",  "32"),
    ("Bool", "true", "Int16", "32"),
    ("Bool", "true", "Int32", "32"),
    ("Bool", "true", "Int64", "32"),
    ("Bool", "true", "UInt",  "32"),
    ("Bool", "true", "UInt8", "32"),
    ("Bool", "true", "UInt16","32"),
    ("Bool", "true", "UInt32","32"),
    ("Bool", "true", "UInt64","32"),
    ("Bool", "true", "Float", "32"),
    ("Bool", "true", "Double","32"),
    ("Bool", "true", "String", '"Test String"'),
    ("Bool", "true", "CodableType", "CodableType(32)"),
]
}%

///
/// Negative tests for keyed containers.
///
class BinaryEncodingKeyedContainerNegativeTests: XCTestCase {

    ///
    /// `decodeNil()` should throw the following error based on the `KeyedDecodingContainerProtocol` protocol.
    ///
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry for the given key.
    ///
    /// And throws the following implementation specific errors:
    ///
    /// - throws: `DecodingError.typeMismatch` if the encountered `StorageContainer` is not convertible to a `SingleValueContainer`.
    ///

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decodeNil for a key not contained in the encoded data.
    ///
    func testDecodeNilWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
            enum AlternateCodingKeys: CodingKey { case invalidValue }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decodeNil(forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// All `decode()` methods should throw the following errors:
    ///
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for the given key.
    ///
    /// And throws the following implementation specific errors:
    ///
    /// - throws: `DecodingError.typeMismatch` if the encountered `StorageContainer` is not convertible to a `SingleValueContainer`.
    ///
%  for (InputTypeName, InputValue, ExpectedTypeName, ExpectedValue) in variants:

    // MARK: - `${ExpectedTypeName}` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecode${ExpectedTypeName}WhenKeyNotFound() {

        struct InputType: Codable {
            var value: ${InputTypeName}
            init(value: ${InputTypeName}) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: ${ExpectedTypeName}
            init(value: ${ExpectedTypeName}) { self.value = value }
            enum AlternateCodingKeys: CodingKey { case invalidValue }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(${ExpectedTypeName}.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: ${InputValue}), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `${ExpectedTypeName}` value that was encoded as an `${InputTypeName}` type when using a KeyedContainer.
    ///
    func testDecode${ExpectedTypeName}WhenTypeMismatch() {

        struct InputType: Codable {
            var value: ${InputTypeName}
            init(value: ${InputTypeName}) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: ${ExpectedTypeName}
            init(value: ${ExpectedTypeName}) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
% if ExpectedTypeName == "CodableType":
        _testDecodeTypeMismatch(input: InputType(value: ${InputValue}), expected: (ExpectedType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [ExpectedType.CodingKeys.value], "Expected to decode KeyedDecodingContainer<CodingKeys> but found SingleValueDecodingContainer instead."))
% else:
        _testDecodeTypeMismatch(input: InputType(value: ${InputValue}), expected: (ExpectedType.self, ${ExpectedTypeName}.self, [ExpectedType.CodingKeys.value], "Expected to decode ${ExpectedTypeName} but found ${InputTypeName} instead."))
% end
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `${ExpectedTypeName}` value that is nil.
    ///
    func testDecode${ExpectedTypeName}WhenValueNotFound() {

        struct InputType: Codable {
            var value: ${ExpectedTypeName}?
            init(value: ${ExpectedTypeName}?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: ${ExpectedTypeName}
            init(value: ${ExpectedTypeName}) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, ${ExpectedTypeName}.self, [ExpectedType.CodingKeys.value], "Expected ${ExpectedTypeName} value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `${ExpectedTypeName}` value and finds a different container type.
    ///
    func testDecode${ExpectedTypeName}WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: ${ExpectedTypeName}
            init(value: ${ExpectedTypeName}) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(${ExpectedTypeName}.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: ${ExpectedTypeName}
            init(value: ${ExpectedTypeName}) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: ${ExpectedValue}), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }
% end
}

