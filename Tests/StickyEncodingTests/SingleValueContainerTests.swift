///
///  SingleValueContainerTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/12/17.
///
import XCTest

@testable import StickyEncoding

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================

///
/// `SingleValueContainerTests`
///
class SingleValueContainerTests: XCTestCase {

    // MARK: - `Bool` Tests
    
    ///
    /// Test that `init` can be called with a `Bool` value.
    ///
    func testInitWithBool() {
        XCTAssertNoThrow(SingleValueContainer(Bool(true)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Bool` value.
    ///
    func testTypeWithBool() {
        XCTAssertEqual((SingleValueContainer(Bool(true))).type, EncodedType.bool)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Bool` value.
    ///
    func testSizeWithBool() {
        XCTAssertEqual((SingleValueContainer(Bool(true))).size, MemoryLayout<Bool>.stride)
    }

    ///
    /// Test that `value` returns the same `Bool` value as it was initialized with.
    ///
    func testValueWithBool() throws {
        XCTAssertEqual(try (SingleValueContainer(Bool(true))).value(as: Bool.self), Bool(true))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Bool` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfBool() throws {
        let input = SingleValueContainer(Bool(true))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Bool.self), try input.value(as: Bool.self))
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Bool` value.
    ///
    func testDescriptionWithBool() throws {
        XCTAssertEqual(SingleValueContainer(Bool(true)).description, String(true))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Bool` value.
    ///
    func testDebugDescriptionWithBool() throws {
        XCTAssertEqual(SingleValueContainer(Bool(true)).debugDescription, "SingleValueContainer(type: Bool, size: \(MemoryLayout<Bool>.stride), value: \(true))")
    }

    // MARK: - `Int` Tests
    
    ///
    /// Test that `init` can be called with a `Int` value.
    ///
    func testInitWithInt() {
        XCTAssertNoThrow(SingleValueContainer(Int(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Int` value.
    ///
    func testTypeWithInt() {
        XCTAssertEqual((SingleValueContainer(Int(32))).type, EncodedType.int)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Int` value.
    ///
    func testSizeWithInt() {
        XCTAssertEqual((SingleValueContainer(Int(32))).size, MemoryLayout<Int>.stride)
    }

    ///
    /// Test that `value` returns the same `Int` value as it was initialized with.
    ///
    func testValueWithInt() throws {
        XCTAssertEqual(try (SingleValueContainer(Int(32))).value(as: Int.self), Int(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Int` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfInt() throws {
        let input = SingleValueContainer(Int(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Int.self), try input.value(as: Int.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `Int.min` value and return the same.
    ///
    func testCanStoreIntMin() throws {
        XCTAssertEqual(try (SingleValueContainer(Int.min)).value(as: Int.self), Int.min)
    }

    ///
    /// Test that `self` can be initialized with a `Int.max` value and return the same.
    ///
    func testCanStoreIntMax() throws {
        XCTAssertEqual(try (SingleValueContainer(Int.max)).value(as: Int.self), Int.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Int` value.
    ///
    func testDescriptionWithInt() throws {
        XCTAssertEqual(SingleValueContainer(Int(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Int` value.
    ///
    func testDebugDescriptionWithInt() throws {
        XCTAssertEqual(SingleValueContainer(Int(32)).debugDescription, "SingleValueContainer(type: Int, size: \(MemoryLayout<Int>.stride), value: \(32))")
    }

    // MARK: - `Int8` Tests
    
    ///
    /// Test that `init` can be called with a `Int8` value.
    ///
    func testInitWithInt8() {
        XCTAssertNoThrow(SingleValueContainer(Int8(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Int8` value.
    ///
    func testTypeWithInt8() {
        XCTAssertEqual((SingleValueContainer(Int8(32))).type, EncodedType.int8)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Int8` value.
    ///
    func testSizeWithInt8() {
        XCTAssertEqual((SingleValueContainer(Int8(32))).size, MemoryLayout<Int8>.stride)
    }

    ///
    /// Test that `value` returns the same `Int8` value as it was initialized with.
    ///
    func testValueWithInt8() throws {
        XCTAssertEqual(try (SingleValueContainer(Int8(32))).value(as: Int8.self), Int8(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Int8` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfInt8() throws {
        let input = SingleValueContainer(Int8(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Int8.self), try input.value(as: Int8.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `Int8.min` value and return the same.
    ///
    func testCanStoreInt8Min() throws {
        XCTAssertEqual(try (SingleValueContainer(Int8.min)).value(as: Int8.self), Int8.min)
    }

    ///
    /// Test that `self` can be initialized with a `Int8.max` value and return the same.
    ///
    func testCanStoreInt8Max() throws {
        XCTAssertEqual(try (SingleValueContainer(Int8.max)).value(as: Int8.self), Int8.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Int8` value.
    ///
    func testDescriptionWithInt8() throws {
        XCTAssertEqual(SingleValueContainer(Int8(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Int8` value.
    ///
    func testDebugDescriptionWithInt8() throws {
        XCTAssertEqual(SingleValueContainer(Int8(32)).debugDescription, "SingleValueContainer(type: Int8, size: \(MemoryLayout<Int8>.stride), value: \(32))")
    }

    // MARK: - `Int16` Tests
    
    ///
    /// Test that `init` can be called with a `Int16` value.
    ///
    func testInitWithInt16() {
        XCTAssertNoThrow(SingleValueContainer(Int16(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Int16` value.
    ///
    func testTypeWithInt16() {
        XCTAssertEqual((SingleValueContainer(Int16(32))).type, EncodedType.int16)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Int16` value.
    ///
    func testSizeWithInt16() {
        XCTAssertEqual((SingleValueContainer(Int16(32))).size, MemoryLayout<Int16>.stride)
    }

    ///
    /// Test that `value` returns the same `Int16` value as it was initialized with.
    ///
    func testValueWithInt16() throws {
        XCTAssertEqual(try (SingleValueContainer(Int16(32))).value(as: Int16.self), Int16(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Int16` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfInt16() throws {
        let input = SingleValueContainer(Int16(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Int16.self), try input.value(as: Int16.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `Int16.min` value and return the same.
    ///
    func testCanStoreInt16Min() throws {
        XCTAssertEqual(try (SingleValueContainer(Int16.min)).value(as: Int16.self), Int16.min)
    }

    ///
    /// Test that `self` can be initialized with a `Int16.max` value and return the same.
    ///
    func testCanStoreInt16Max() throws {
        XCTAssertEqual(try (SingleValueContainer(Int16.max)).value(as: Int16.self), Int16.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Int16` value.
    ///
    func testDescriptionWithInt16() throws {
        XCTAssertEqual(SingleValueContainer(Int16(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Int16` value.
    ///
    func testDebugDescriptionWithInt16() throws {
        XCTAssertEqual(SingleValueContainer(Int16(32)).debugDescription, "SingleValueContainer(type: Int16, size: \(MemoryLayout<Int16>.stride), value: \(32))")
    }

    // MARK: - `Int32` Tests
    
    ///
    /// Test that `init` can be called with a `Int32` value.
    ///
    func testInitWithInt32() {
        XCTAssertNoThrow(SingleValueContainer(Int32(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Int32` value.
    ///
    func testTypeWithInt32() {
        XCTAssertEqual((SingleValueContainer(Int32(32))).type, EncodedType.int32)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Int32` value.
    ///
    func testSizeWithInt32() {
        XCTAssertEqual((SingleValueContainer(Int32(32))).size, MemoryLayout<Int32>.stride)
    }

    ///
    /// Test that `value` returns the same `Int32` value as it was initialized with.
    ///
    func testValueWithInt32() throws {
        XCTAssertEqual(try (SingleValueContainer(Int32(32))).value(as: Int32.self), Int32(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Int32` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfInt32() throws {
        let input = SingleValueContainer(Int32(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Int32.self), try input.value(as: Int32.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `Int32.min` value and return the same.
    ///
    func testCanStoreInt32Min() throws {
        XCTAssertEqual(try (SingleValueContainer(Int32.min)).value(as: Int32.self), Int32.min)
    }

    ///
    /// Test that `self` can be initialized with a `Int32.max` value and return the same.
    ///
    func testCanStoreInt32Max() throws {
        XCTAssertEqual(try (SingleValueContainer(Int32.max)).value(as: Int32.self), Int32.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Int32` value.
    ///
    func testDescriptionWithInt32() throws {
        XCTAssertEqual(SingleValueContainer(Int32(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Int32` value.
    ///
    func testDebugDescriptionWithInt32() throws {
        XCTAssertEqual(SingleValueContainer(Int32(32)).debugDescription, "SingleValueContainer(type: Int32, size: \(MemoryLayout<Int32>.stride), value: \(32))")
    }

    // MARK: - `Int64` Tests
    
    ///
    /// Test that `init` can be called with a `Int64` value.
    ///
    func testInitWithInt64() {
        XCTAssertNoThrow(SingleValueContainer(Int64(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Int64` value.
    ///
    func testTypeWithInt64() {
        XCTAssertEqual((SingleValueContainer(Int64(32))).type, EncodedType.int64)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Int64` value.
    ///
    func testSizeWithInt64() {
        XCTAssertEqual((SingleValueContainer(Int64(32))).size, MemoryLayout<Int64>.stride)
    }

    ///
    /// Test that `value` returns the same `Int64` value as it was initialized with.
    ///
    func testValueWithInt64() throws {
        XCTAssertEqual(try (SingleValueContainer(Int64(32))).value(as: Int64.self), Int64(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Int64` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfInt64() throws {
        let input = SingleValueContainer(Int64(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Int64.self), try input.value(as: Int64.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `Int64.min` value and return the same.
    ///
    func testCanStoreInt64Min() throws {
        XCTAssertEqual(try (SingleValueContainer(Int64.min)).value(as: Int64.self), Int64.min)
    }

    ///
    /// Test that `self` can be initialized with a `Int64.max` value and return the same.
    ///
    func testCanStoreInt64Max() throws {
        XCTAssertEqual(try (SingleValueContainer(Int64.max)).value(as: Int64.self), Int64.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Int64` value.
    ///
    func testDescriptionWithInt64() throws {
        XCTAssertEqual(SingleValueContainer(Int64(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Int64` value.
    ///
    func testDebugDescriptionWithInt64() throws {
        XCTAssertEqual(SingleValueContainer(Int64(32)).debugDescription, "SingleValueContainer(type: Int64, size: \(MemoryLayout<Int64>.stride), value: \(32))")
    }

    // MARK: - `UInt` Tests
    
    ///
    /// Test that `init` can be called with a `UInt` value.
    ///
    func testInitWithUInt() {
        XCTAssertNoThrow(SingleValueContainer(UInt(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `UInt` value.
    ///
    func testTypeWithUInt() {
        XCTAssertEqual((SingleValueContainer(UInt(32))).type, EncodedType.uint)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `UInt` value.
    ///
    func testSizeWithUInt() {
        XCTAssertEqual((SingleValueContainer(UInt(32))).size, MemoryLayout<UInt>.stride)
    }

    ///
    /// Test that `value` returns the same `UInt` value as it was initialized with.
    ///
    func testValueWithUInt() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt(32))).value(as: UInt.self), UInt(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `UInt` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfUInt() throws {
        let input = SingleValueContainer(UInt(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: UInt.self), try input.value(as: UInt.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `UInt.min` value and return the same.
    ///
    func testCanStoreUIntMin() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt.min)).value(as: UInt.self), UInt.min)
    }

    ///
    /// Test that `self` can be initialized with a `UInt.max` value and return the same.
    ///
    func testCanStoreUIntMax() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt.max)).value(as: UInt.self), UInt.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `UInt` value.
    ///
    func testDescriptionWithUInt() throws {
        XCTAssertEqual(SingleValueContainer(UInt(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `UInt` value.
    ///
    func testDebugDescriptionWithUInt() throws {
        XCTAssertEqual(SingleValueContainer(UInt(32)).debugDescription, "SingleValueContainer(type: UInt, size: \(MemoryLayout<UInt>.stride), value: \(32))")
    }

    // MARK: - `UInt8` Tests
    
    ///
    /// Test that `init` can be called with a `UInt8` value.
    ///
    func testInitWithUInt8() {
        XCTAssertNoThrow(SingleValueContainer(UInt8(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `UInt8` value.
    ///
    func testTypeWithUInt8() {
        XCTAssertEqual((SingleValueContainer(UInt8(32))).type, EncodedType.uint8)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `UInt8` value.
    ///
    func testSizeWithUInt8() {
        XCTAssertEqual((SingleValueContainer(UInt8(32))).size, MemoryLayout<UInt8>.stride)
    }

    ///
    /// Test that `value` returns the same `UInt8` value as it was initialized with.
    ///
    func testValueWithUInt8() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt8(32))).value(as: UInt8.self), UInt8(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `UInt8` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfUInt8() throws {
        let input = SingleValueContainer(UInt8(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: UInt8.self), try input.value(as: UInt8.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `UInt8.min` value and return the same.
    ///
    func testCanStoreUInt8Min() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt8.min)).value(as: UInt8.self), UInt8.min)
    }

    ///
    /// Test that `self` can be initialized with a `UInt8.max` value and return the same.
    ///
    func testCanStoreUInt8Max() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt8.max)).value(as: UInt8.self), UInt8.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `UInt8` value.
    ///
    func testDescriptionWithUInt8() throws {
        XCTAssertEqual(SingleValueContainer(UInt8(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `UInt8` value.
    ///
    func testDebugDescriptionWithUInt8() throws {
        XCTAssertEqual(SingleValueContainer(UInt8(32)).debugDescription, "SingleValueContainer(type: UInt8, size: \(MemoryLayout<UInt8>.stride), value: \(32))")
    }

    // MARK: - `UInt16` Tests
    
    ///
    /// Test that `init` can be called with a `UInt16` value.
    ///
    func testInitWithUInt16() {
        XCTAssertNoThrow(SingleValueContainer(UInt16(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `UInt16` value.
    ///
    func testTypeWithUInt16() {
        XCTAssertEqual((SingleValueContainer(UInt16(32))).type, EncodedType.uint16)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `UInt16` value.
    ///
    func testSizeWithUInt16() {
        XCTAssertEqual((SingleValueContainer(UInt16(32))).size, MemoryLayout<UInt16>.stride)
    }

    ///
    /// Test that `value` returns the same `UInt16` value as it was initialized with.
    ///
    func testValueWithUInt16() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt16(32))).value(as: UInt16.self), UInt16(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `UInt16` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfUInt16() throws {
        let input = SingleValueContainer(UInt16(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: UInt16.self), try input.value(as: UInt16.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `UInt16.min` value and return the same.
    ///
    func testCanStoreUInt16Min() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt16.min)).value(as: UInt16.self), UInt16.min)
    }

    ///
    /// Test that `self` can be initialized with a `UInt16.max` value and return the same.
    ///
    func testCanStoreUInt16Max() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt16.max)).value(as: UInt16.self), UInt16.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `UInt16` value.
    ///
    func testDescriptionWithUInt16() throws {
        XCTAssertEqual(SingleValueContainer(UInt16(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `UInt16` value.
    ///
    func testDebugDescriptionWithUInt16() throws {
        XCTAssertEqual(SingleValueContainer(UInt16(32)).debugDescription, "SingleValueContainer(type: UInt16, size: \(MemoryLayout<UInt16>.stride), value: \(32))")
    }

    // MARK: - `UInt32` Tests
    
    ///
    /// Test that `init` can be called with a `UInt32` value.
    ///
    func testInitWithUInt32() {
        XCTAssertNoThrow(SingleValueContainer(UInt32(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `UInt32` value.
    ///
    func testTypeWithUInt32() {
        XCTAssertEqual((SingleValueContainer(UInt32(32))).type, EncodedType.uint32)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `UInt32` value.
    ///
    func testSizeWithUInt32() {
        XCTAssertEqual((SingleValueContainer(UInt32(32))).size, MemoryLayout<UInt32>.stride)
    }

    ///
    /// Test that `value` returns the same `UInt32` value as it was initialized with.
    ///
    func testValueWithUInt32() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt32(32))).value(as: UInt32.self), UInt32(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `UInt32` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfUInt32() throws {
        let input = SingleValueContainer(UInt32(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: UInt32.self), try input.value(as: UInt32.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `UInt32.min` value and return the same.
    ///
    func testCanStoreUInt32Min() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt32.min)).value(as: UInt32.self), UInt32.min)
    }

    ///
    /// Test that `self` can be initialized with a `UInt32.max` value and return the same.
    ///
    func testCanStoreUInt32Max() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt32.max)).value(as: UInt32.self), UInt32.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `UInt32` value.
    ///
    func testDescriptionWithUInt32() throws {
        XCTAssertEqual(SingleValueContainer(UInt32(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `UInt32` value.
    ///
    func testDebugDescriptionWithUInt32() throws {
        XCTAssertEqual(SingleValueContainer(UInt32(32)).debugDescription, "SingleValueContainer(type: UInt32, size: \(MemoryLayout<UInt32>.stride), value: \(32))")
    }

    // MARK: - `UInt64` Tests
    
    ///
    /// Test that `init` can be called with a `UInt64` value.
    ///
    func testInitWithUInt64() {
        XCTAssertNoThrow(SingleValueContainer(UInt64(32)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `UInt64` value.
    ///
    func testTypeWithUInt64() {
        XCTAssertEqual((SingleValueContainer(UInt64(32))).type, EncodedType.uint64)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `UInt64` value.
    ///
    func testSizeWithUInt64() {
        XCTAssertEqual((SingleValueContainer(UInt64(32))).size, MemoryLayout<UInt64>.stride)
    }

    ///
    /// Test that `value` returns the same `UInt64` value as it was initialized with.
    ///
    func testValueWithUInt64() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt64(32))).value(as: UInt64.self), UInt64(32))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `UInt64` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfUInt64() throws {
        let input = SingleValueContainer(UInt64(32))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: UInt64.self), try input.value(as: UInt64.self))
    }
    
    ///
    /// Test that `self` can be initialized with a `UInt64.min` value and return the same.
    ///
    func testCanStoreUInt64Min() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt64.min)).value(as: UInt64.self), UInt64.min)
    }

    ///
    /// Test that `self` can be initialized with a `UInt64.max` value and return the same.
    ///
    func testCanStoreUInt64Max() throws {
        XCTAssertEqual(try (SingleValueContainer(UInt64.max)).value(as: UInt64.self), UInt64.max)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `UInt64` value.
    ///
    func testDescriptionWithUInt64() throws {
        XCTAssertEqual(SingleValueContainer(UInt64(32)).description, String(32))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `UInt64` value.
    ///
    func testDebugDescriptionWithUInt64() throws {
        XCTAssertEqual(SingleValueContainer(UInt64(32)).debugDescription, "SingleValueContainer(type: UInt64, size: \(MemoryLayout<UInt64>.stride), value: \(32))")
    }

    // MARK: - `Float` Tests
    
    ///
    /// Test that `init` can be called with a `Float` value.
    ///
    func testInitWithFloat() {
        XCTAssertNoThrow(SingleValueContainer(Float(32.0)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Float` value.
    ///
    func testTypeWithFloat() {
        XCTAssertEqual((SingleValueContainer(Float(32.0))).type, EncodedType.float)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Float` value.
    ///
    func testSizeWithFloat() {
        XCTAssertEqual((SingleValueContainer(Float(32.0))).size, MemoryLayout<Float>.stride)
    }

    ///
    /// Test that `value` returns the same `Float` value as it was initialized with.
    ///
    func testValueWithFloat() throws {
        XCTAssertEqual(try (SingleValueContainer(Float(32.0))).value(as: Float.self), Float(32.0))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Float` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfFloat() throws {
        let input = SingleValueContainer(Float(32.0))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Float.self), try input.value(as: Float.self))
    }
    ///
    /// Test that `self` can be initialized with a `Float.infinity` value and return the same.
    ///
    func testCanStoreFloatInfinity() throws {
        XCTAssertEqual(try (SingleValueContainer(Float.infinity)).value(as: Float.self), Float.infinity)
    }

    ///
    /// Test that `self` can be initialized with a `Float.nan` value and return the same.
    ///
    func testCanStoreFloatNan() throws {
        XCTAssertEqual(try (SingleValueContainer(Float.nan)).value(as: Float.self).isNaN, true)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Float` value.
    ///
    func testDescriptionWithFloat() throws {
        XCTAssertEqual(SingleValueContainer(Float(32.0)).description, String(32.0))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Float` value.
    ///
    func testDebugDescriptionWithFloat() throws {
        XCTAssertEqual(SingleValueContainer(Float(32.0)).debugDescription, "SingleValueContainer(type: Float, size: \(MemoryLayout<Float>.stride), value: \(32.0))")
    }

    // MARK: - `Double` Tests
    
    ///
    /// Test that `init` can be called with a `Double` value.
    ///
    func testInitWithDouble() {
        XCTAssertNoThrow(SingleValueContainer(Double(32.0)))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `Double` value.
    ///
    func testTypeWithDouble() {
        XCTAssertEqual((SingleValueContainer(Double(32.0))).type, EncodedType.double)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `Double` value.
    ///
    func testSizeWithDouble() {
        XCTAssertEqual((SingleValueContainer(Double(32.0))).size, MemoryLayout<Double>.stride)
    }

    ///
    /// Test that `value` returns the same `Double` value as it was initialized with.
    ///
    func testValueWithDouble() throws {
        XCTAssertEqual(try (SingleValueContainer(Double(32.0))).value(as: Double.self), Double(32.0))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `Double` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfDouble() throws {
        let input = SingleValueContainer(Double(32.0))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: Double.self), try input.value(as: Double.self))
    }
    ///
    /// Test that `self` can be initialized with a `Double.infinity` value and return the same.
    ///
    func testCanStoreDoubleInfinity() throws {
        XCTAssertEqual(try (SingleValueContainer(Double.infinity)).value(as: Double.self), Double.infinity)
    }

    ///
    /// Test that `self` can be initialized with a `Double.nan` value and return the same.
    ///
    func testCanStoreDoubleNan() throws {
        XCTAssertEqual(try (SingleValueContainer(Double.nan)).value(as: Double.self).isNaN, true)
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `Double` value.
    ///
    func testDescriptionWithDouble() throws {
        XCTAssertEqual(SingleValueContainer(Double(32.0)).description, String(32.0))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `Double` value.
    ///
    func testDebugDescriptionWithDouble() throws {
        XCTAssertEqual(SingleValueContainer(Double(32.0)).debugDescription, "SingleValueContainer(type: Double, size: \(MemoryLayout<Double>.stride), value: \(32.0))")
    }

    // MARK: - `String` Tests
    
    ///
    /// Test that `init` can be called with a `String` value.
    ///
    func testInitWithString() {
        XCTAssertNoThrow(SingleValueContainer(String("Test String")))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `String` value.
    ///
    func testTypeWithString() {
        XCTAssertEqual((SingleValueContainer(String("Test String"))).type, EncodedType.string)
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `String` value.
    ///
    func testSizeWithString() {
        XCTAssertEqual((SingleValueContainer(String("Test String"))).size, MemoryLayout<Unicode.UTF8.CodeUnit>.stride * "Test String".utf8.count)
    }

    ///
    /// Test that `value` returns the same `String` value as it was initialized with.
    ///
    func testValueWithString() throws {
        XCTAssertEqual(try (SingleValueContainer(String("Test String"))).value(as: String.self), String("Test String"))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `String` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOfString() throws {
        let input = SingleValueContainer(String("Test String"))

        let buffer = UnsafeMutableRawBufferPointer.allocate(byteCount: input.byteCount, alignment: MemoryLayout<UInt8>.alignment)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: String.self), try input.value(as: String.self))
    }
    
    ///
    /// Test that the `description` value is correct after being initialized with a `String` value.
    ///
    func testDescriptionWithString() throws {
        XCTAssertEqual(SingleValueContainer(String("Test String")).description, String("Test String"))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `String` value.
    ///
    func testDebugDescriptionWithString() throws {
        XCTAssertEqual(SingleValueContainer(String("Test String")).debugDescription, "SingleValueContainer(type: String, size: \(MemoryLayout<Unicode.UTF8.CodeUnit>.stride * "Test String".utf8.count), value: \("Test String"))")
    }
    // MARK: - `String` Extended Tests

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode Globes and return the same.
    ///
    func testCanStoreStringUnicodeGlobes() throws {
        XCTAssertEqual(try (SingleValueContainer("🌍🌍🌍🌍🌍🌍🌍🌍🌍")).value(as: String.self), "🌍🌍🌍🌍🌍🌍🌍🌍🌍")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode Flags and return the same.
    ///
    func testCanStoreStringUnicodeFlags() throws {
        XCTAssertEqual(try (SingleValueContainer("🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷")).value(as: String.self), "🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode EPlusAccent and return the same.
    ///
    func testCanStoreStringUnicodeEPlusAccent() throws {
        XCTAssertEqual(try (SingleValueContainer("e\u{0301}")).value(as: String.self), "e\u{0301}")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode EWithAccent and return the same.
    ///
    func testCanStoreStringUnicodeEWithAccent() throws {
        XCTAssertEqual(try (SingleValueContainer("é")).value(as: String.self), "é")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of a 100k size random String and return the same.
    ///
    func testCanStoreLargeRandomString100k() throws {
        let expected = String.random(length: 102400)

        XCTAssertEqual(try (SingleValueContainer(expected)).value(as: String.self), expected)
    }

    ///
    /// Test that `self` can be initialized with a `String` value of a 1000k size random String and return the same.
    ///
    func testCanStoreLargeRandomString1000k() throws {
        let expected = String.random(length: 1024000)

        XCTAssertEqual(try (SingleValueContainer(expected)).value(as: String.self), expected)
    }
}

///
/// `SingleValueContainerPerformanceTests`
///
class SingleValueContainerPerformanceTests: XCTestCase {
            
    // MARK: - `Bool` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Bool`.
    ///
    func testInitWithBoolPerformance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Bool(true))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Bool`.
    ///
    func testTypeWithBoolPerformance() throws {
        let container = SingleValueContainer(Bool(true))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Bool`.
    ///
    func testSizeWithBoolPerformance() throws {
        let container = SingleValueContainer(Bool(true))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Bool`.
    ///
    func testValueWithBoolPerformance() throws {
        let container = SingleValueContainer(Bool(true))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Bool.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `Int` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Int`.
    ///
    func testInitWithIntPerformance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Int(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Int`.
    ///
    func testTypeWithIntPerformance() throws {
        let container = SingleValueContainer(Int(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Int`.
    ///
    func testSizeWithIntPerformance() throws {
        let container = SingleValueContainer(Int(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Int`.
    ///
    func testValueWithIntPerformance() throws {
        let container = SingleValueContainer(Int(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Int.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `Int8` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Int8`.
    ///
    func testInitWithInt8Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Int8(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Int8`.
    ///
    func testTypeWithInt8Performance() throws {
        let container = SingleValueContainer(Int8(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Int8`.
    ///
    func testSizeWithInt8Performance() throws {
        let container = SingleValueContainer(Int8(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Int8`.
    ///
    func testValueWithInt8Performance() throws {
        let container = SingleValueContainer(Int8(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Int8.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `Int16` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Int16`.
    ///
    func testInitWithInt16Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Int16(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Int16`.
    ///
    func testTypeWithInt16Performance() throws {
        let container = SingleValueContainer(Int16(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Int16`.
    ///
    func testSizeWithInt16Performance() throws {
        let container = SingleValueContainer(Int16(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Int16`.
    ///
    func testValueWithInt16Performance() throws {
        let container = SingleValueContainer(Int16(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Int16.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `Int32` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Int32`.
    ///
    func testInitWithInt32Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Int32(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Int32`.
    ///
    func testTypeWithInt32Performance() throws {
        let container = SingleValueContainer(Int32(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Int32`.
    ///
    func testSizeWithInt32Performance() throws {
        let container = SingleValueContainer(Int32(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Int32`.
    ///
    func testValueWithInt32Performance() throws {
        let container = SingleValueContainer(Int32(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Int32.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `Int64` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Int64`.
    ///
    func testInitWithInt64Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Int64(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Int64`.
    ///
    func testTypeWithInt64Performance() throws {
        let container = SingleValueContainer(Int64(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Int64`.
    ///
    func testSizeWithInt64Performance() throws {
        let container = SingleValueContainer(Int64(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Int64`.
    ///
    func testValueWithInt64Performance() throws {
        let container = SingleValueContainer(Int64(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Int64.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `UInt` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `UInt`.
    ///
    func testInitWithUIntPerformance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(UInt(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `UInt`.
    ///
    func testTypeWithUIntPerformance() throws {
        let container = SingleValueContainer(UInt(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `UInt`.
    ///
    func testSizeWithUIntPerformance() throws {
        let container = SingleValueContainer(UInt(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `UInt`.
    ///
    func testValueWithUIntPerformance() throws {
        let container = SingleValueContainer(UInt(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: UInt.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `UInt8` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `UInt8`.
    ///
    func testInitWithUInt8Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(UInt8(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `UInt8`.
    ///
    func testTypeWithUInt8Performance() throws {
        let container = SingleValueContainer(UInt8(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `UInt8`.
    ///
    func testSizeWithUInt8Performance() throws {
        let container = SingleValueContainer(UInt8(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `UInt8`.
    ///
    func testValueWithUInt8Performance() throws {
        let container = SingleValueContainer(UInt8(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: UInt8.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `UInt16` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `UInt16`.
    ///
    func testInitWithUInt16Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(UInt16(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `UInt16`.
    ///
    func testTypeWithUInt16Performance() throws {
        let container = SingleValueContainer(UInt16(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `UInt16`.
    ///
    func testSizeWithUInt16Performance() throws {
        let container = SingleValueContainer(UInt16(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `UInt16`.
    ///
    func testValueWithUInt16Performance() throws {
        let container = SingleValueContainer(UInt16(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: UInt16.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `UInt32` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `UInt32`.
    ///
    func testInitWithUInt32Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(UInt32(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `UInt32`.
    ///
    func testTypeWithUInt32Performance() throws {
        let container = SingleValueContainer(UInt32(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `UInt32`.
    ///
    func testSizeWithUInt32Performance() throws {
        let container = SingleValueContainer(UInt32(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `UInt32`.
    ///
    func testValueWithUInt32Performance() throws {
        let container = SingleValueContainer(UInt32(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: UInt32.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `UInt64` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `UInt64`.
    ///
    func testInitWithUInt64Performance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(UInt64(32))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `UInt64`.
    ///
    func testTypeWithUInt64Performance() throws {
        let container = SingleValueContainer(UInt64(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `UInt64`.
    ///
    func testSizeWithUInt64Performance() throws {
        let container = SingleValueContainer(UInt64(32))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `UInt64`.
    ///
    func testValueWithUInt64Performance() throws {
        let container = SingleValueContainer(UInt64(32))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: UInt64.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `Float` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Float`.
    ///
    func testInitWithFloatPerformance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Float(32.0))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Float`.
    ///
    func testTypeWithFloatPerformance() throws {
        let container = SingleValueContainer(Float(32.0))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Float`.
    ///
    func testSizeWithFloatPerformance() throws {
        let container = SingleValueContainer(Float(32.0))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Float`.
    ///
    func testValueWithFloatPerformance() throws {
        let container = SingleValueContainer(Float(32.0))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Float.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `Double` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `Double`.
    ///
    func testInitWithDoublePerformance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(Double(32.0))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `Double`.
    ///
    func testTypeWithDoublePerformance() throws {
        let container = SingleValueContainer(Double(32.0))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `Double`.
    ///
    func testSizeWithDoublePerformance() throws {
        let container = SingleValueContainer(Double(32.0))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `Double`.
    ///
    func testValueWithDoublePerformance() throws {
        let container = SingleValueContainer(Double(32.0))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: Double.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
            
    // MARK: - `String` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `String`.
    ///
    func testInitWithStringPerformance() {

        self.measure {
            for _ in 1...5000 {
                let _ = SingleValueContainer(String("Test String"))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `String`.
    ///
    func testTypeWithStringPerformance() throws {
        let container = SingleValueContainer(String("Test String"))

        self.measure {
            for _ in 1...5000 {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `String`.
    ///
    func testSizeWithStringPerformance() throws {
        let container = SingleValueContainer(String("Test String"))

        self.measure {
            for _ in 1...5000 {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `String`.
    ///
    func testValueWithStringPerformance() throws {
        let container = SingleValueContainer(String("Test String"))

        self.measure {
            do {
                for _ in 1...5000 {
                    let _ = try container.value(as: String.self)
                }
            } catch {
                XCTFail()
            }
        }
    }

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a large string of 100k size.
    ///
    func testInitWithLargeRandomString100kPerformance() throws {
        let value = String.random(length: 102400)

        self.measure {
            let _ = SingleValueContainer(value)
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a large string of 100k size.
    ///
    func testValueWithLargeRandomString100kPerformance() throws {
        let container = SingleValueContainer(String.random(length: 102400))

        self.measure {
            do {
                let _ = try container.value(as: String.self)
            } catch {
                XCTFail()
            }
        }
    }

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a large string of 1000k size.
    ///
    func testInitWithLargeRandomString1000kPerformance() throws {
        let value = String.random(length: 1024000)

        self.measure {
            let _ = SingleValueContainer(value)
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a large string of 1000åk size.
    ///
    func testValueWithLargeRandomString1000kPerformance() throws {
        let container = SingleValueContainer(String.random(length: 1024000))

        self.measure {
            do {
                let _ = try container.value(as: String.self)
            } catch {
                XCTFail()
            }
        }
    }
}

///
/// String extension to create a random string of a given size.
///
extension String {

    static func random(length: Int = 1024) -> String {
        let chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        var string = String()
        string.reserveCapacity(length)

        #if os(Linux) || os(FreeBSD)
            ///srandom(UInt32(time(nil)))
        #endif

        for _ in 0..<length {
            #if os(Linux) || os(FreeBSD)
                /// FIXME: Currently (Swift 4) random() produces a string on linux and also crashes when called. To test, we simply produce a string with a sequence of letter 'a'.
                let randomValue = 0 // random() % chars.characters.count
            #else
                let randomValue = arc4random_uniform(UInt32(chars.count))
            #endif

            string.append("\(chars[chars.index(chars.startIndex, offsetBy: Int(randomValue))])")
        }
        return string
    }
}
