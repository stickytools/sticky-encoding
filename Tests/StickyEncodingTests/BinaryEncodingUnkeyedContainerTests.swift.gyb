///
///  BinaryEncodingUnkeyedContainerTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/6/17.
///
import XCTest
import TestFixtures

///
/// Note: This file contains public interface tests so do not use @testable.
///
import StickyEncoding

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================
%{
variants = [
    ("Bool",    "Bool", "true", "true"),
    ("Integer", "Int", "32", "32"),
    ("Integer", "Int8", "32", "32"),
    ("Integer", "Int16", "32", "32"),
    ("Integer", "Int32", "32", "32"),
    ("Integer", "Int64", "32", "32"),
    ("Integer", "UInt", "32", "32"),
    ("Integer", "UInt8", "32", "32"),
    ("Integer", "UInt16", "32", "32"),
    ("Integer", "UInt32", "32", "32"),
    ("Integer", "UInt64", "32", "32"),
    ("Float", "Float", "32.0", "32.0"),
    ("Float", "Double", "32.0", "32.0"),
    ("Object",  "String", '"Test String"', '"Test String"'),
    ("Object", "CodableType", "CodableType(32)", "CodableType(32)")
]
}%

///
/// Tests relating to both `BinaryEncoder` and `BinaryDecoder` for unkeyed containers when encoding structured types (custom class and structs).
///
class BinaryEncodingUnkeyedContainerTests: XCTestCase {
%  for (Group, TypeName, Input, Expected) in variants:

    // MARK: - `${TypeName}` Tests

% for Type in ["class", "struct"]:

    ///
    /// Test the ability to encode/decode a ${Type} with a `${TypeName}` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOf${Type.title()}${TypeName}Unkeyed() {

        ${Type} InputType: Codable {
            var value: ${TypeName}
            init(value: ${TypeName}) { self.value = value }

% if Type == "class":
            required
% end
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(${TypeName}.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: ${Input})) { (result) in
            XCTAssertEqual(result.value, ${Expected})
        }
    }

    ///
    /// Test the ability to encode/decode a ${Type} with an optional `${TypeName}` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOf${Type.title()}Optional${TypeName}Unkeyed() {

        ${Type} InputType: Codable {
            var value: ${TypeName}?
            init(value: ${TypeName}?) { self.value = value }

% if Type == "class":
            required
% end
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(${TypeName}.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: ${Input})) { (result) in
            XCTAssertEqual(result.value, ${Expected})
        }
    }

    ///
    /// Test the ability to encode/decode a ${Type} with an optional `${TypeName}` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOf${Type.title()}Optional${TypeName}WithNilUnkeyed() {

        ${Type} InputType: Codable {
            var value: ${TypeName}?
            init(value: ${TypeName}?) { self.value = value }

% if Type == "class":
            required
% end
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(${TypeName}.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }
% end
% end

    ///
    /// Test the ability to encodeNil/decodeNil using a UnkeyedContainer.
    ///
    func testEncodeNilWithUnkeyedContainer() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()

                if !(try container.decodeNil()) {
                    self.value = try container.decode(String.self)
                }
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()

                if let value = self.value {
                    try container.encode(value)
                } else {
                    try container.encodeNil()
                }
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested KeyedContainer from a UnkeyedContainer.
    ///
    func testEncodeDecodeWithUnkeyedAndNestedUnkeyedContainer() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                var nestedContainer = try container.nestedUnkeyedContainer()

                self.first = try nestedContainer.decode(String.self)
                self.last  = try nestedContainer.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()

                try nestedContainer.encode(self.first)
                try nestedContainer.encode(self.last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested UnkeyedContainer from a UnkeyedContainer.
    ///
    func testEncodeDecodeWithUnkeyedAndNestedKeyedContainers() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                let nestedContainer = try container.nestedContainer(keyedBy: NestedKeys.self)

                self.first = try nestedContainer.decode(String.self, forKey: .first)
                self.last  = try nestedContainer.decode(String.self, forKey: .last)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedContainer(keyedBy: NestedKeys.self)

                try nestedContainer.encode(self.first, forKey: .first)
                try nestedContainer.encode(self.last,  forKey: .last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value calling unkeyedContainer  multiple times.
    ///
    func testEncodeCallingMultipleUnkeyedContainers() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }

            init(from decoder: Decoder) throws {
                var _ = try decoder.unkeyedContainer()
                var container = try decoder.unkeyedContainer()

                self.value = try container.decode(String.self)
            }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer() /// throw the first away
                let _ = encoder.unkeyedContainer() /// And the second

                /// Use the third
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test Value")) { (result) in
            XCTAssertEqual(result.value, "Test Value")
        }
    }

    ///
    /// Test that the UnkeyedContainer's `count` implementation returns the correct value.
    ///
    func testEncodeDecodeUnkeyedContainerCount() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()

                self.first = try container.decode(String.self)
                self.last  = try container.decode(String.self)

                ///
                /// Note: Actual test for count is here
                ///
                XCTAssertEqual(container.count, 2)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()

                try container.encode(self.first)
                try container.encode(self.last)

                ///
                /// Note: Actual test for count is here
                ///
                XCTAssertEqual(container.count, 2)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode of a class/struct type using an `UnkeyedContainer`.
    ///
    func testEncodeDecodeOfStructClassType() {

        class InputValueType: Codable {
            let value: Int
            init(value: Int) { self.value = value }
            private enum CodingKeys: CodingKey { case value }

            required init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        class InputType: Codable {
            let value: InputValueType
            init(value: InputValueType) { self.value = value }
            private enum CodingKeys: CodingKey { case value }

            required init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(InputValueType.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: InputValueType(value: 32))) { (result) in
            XCTAssertEqual(result.value.value, 32)
        }
    }

}
