///
///  BinaryEncodingSingleValueContainerNegativeTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/23/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import StickyEncoding

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================
%{
variants = [
    ("Int", "64",    "Bool", "true"),
    ("Bool", "true", "Int",  "32"),
    ("Bool", "true", "Int8",  "32"),
    ("Bool", "true", "Int16",  "32"),
    ("Bool", "true", "Int32",  "32"),
    ("Bool", "true", "Int64",  "32"),
    ("Bool", "true", "UInt",  "32"),
    ("Bool", "true", "UInt8",  "32"),
    ("Bool", "true", "UInt16",  "32"),
    ("Bool", "true", "UInt32",  "32"),
    ("Bool", "true", "UInt64",  "32"),
    ("Bool", "true", "Float",  "32.0"),
    ("Bool", "true", "Double",  "32.0"),
    ("Bool", "true", "String", '"Test String"'),
]
}%

///
/// Negative tests for  single value containers.
///
class BinaryEncodingSingleValueContainerNegativeTests: XCTestCase {
%  for (InputTypeName, InputValue, ExpectedTypeName, ExpectedValue) in variants:

    // MARK: - `${ExpectedTypeName}` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `${ExpectedTypeName}` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOf${ExpectedTypeName}() {
        _testDecodeValueNotFound(input: Optional<${InputTypeName}>.none, expected: (${ExpectedTypeName}.self, ${ExpectedTypeName}.self, [], "Expected ${ExpectedTypeName} value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `${ExpectedTypeName}` value that was encoded as an `${InputTypeName}` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOf${ExpectedTypeName}() {
        _testDecodeTypeMismatch(input: ${InputTypeName}(${InputValue}), expected: (${ExpectedTypeName}.self, ${ExpectedTypeName}.self, [], "Expected to decode ${ExpectedTypeName} but found ${InputTypeName} instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `${ExpectedTypeName}` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOf${ExpectedTypeName}WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: ${ExpectedTypeName}
            init(value: ${ExpectedTypeName}) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: ${ExpectedValue}), expected: (${ExpectedTypeName}.self, ${ExpectedTypeName}.self, [], "Expected to decode ${ExpectedTypeName} but found KeyedDecodingContainer<CodingKeys> instead."))
    }
% end

    // MARK: - `CodableType` Tests

    ///
    /// Note: Currently codable types using a SingleValueDecodingContainer have different error messages and type that single values because of the nature of the encoding.
    ///

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `CodableType` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfCodableType() {
        _testDecodeValueNotFound(input: Optional<Bool>.none, expected: (CodableType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [], "Expected KeyedDecodingContainer<CodingKeys> value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value that was encoded as an `Bool` type when decoding a root-level value.
    ///
    func testDecodeTypeMismatchOfCodableType() {
        _testDecodeTypeMismatch(input: Bool(true), expected: (CodableType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found SingleValueDecodingContainer instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value at the root-level and finds a container other that a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfCodableTypeWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: CodableType(32)), expected: (CodableType.self, Int.self, [CodableType.CodingKeys.value], "Expected to decode Int but found KeyedDecodingContainer<CodingKeys> instead."))
    }
}
