///
///  SingleValueContainerTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/12/17.
///
import XCTest

@testable import StickyEncoding

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================
%{
variants = [
    ("Bool",    "Bool", "true", "true"),
    ("Integer", "Int", "32", "32"),
    ("Integer", "Int8", "32", "32"),
    ("Integer", "Int16", "32", "32"),
    ("Integer", "Int32", "32", "32"),
    ("Integer", "Int64", "32", "32"),
    ("Integer", "UInt", "32", "32"),
    ("Integer", "UInt8", "32", "32"),
    ("Integer", "UInt16", "32", "32"),
    ("Integer", "UInt32", "32", "32"),
    ("Integer", "UInt64", "32", "32"),
    ("Float", "Float", "32.0", "32.0"),
    ("Float", "Double", "32.0", "32.0"),
    ("Object",  "String", '"Test String"', '"Test String"'),
]
}%

///
/// `SingleValueContainerTests`
///
class SingleValueContainerTests: XCTestCase {
%  for (Group, Type, Input, Expected) in variants:

    // MARK: - `${Type}` Tests
%{
if Type == 'String':
    InputSize = "MemoryLayout<Unicode.UTF8.CodeUnit>.stride * " + Input + ".utf8.count"
else:
    InputSize = "MemoryLayout<" + Type + ">.stride"
}%
    
    ///
    /// Test that `init` can be called with a `${Type}` value.
    ///
    func testInitWith${Type}() {
        XCTAssertNoThrow(SingleValueContainer(${Type}(${Input})))
    }

    ///
    /// Test that `type` returns the proper type after being initialize with a `${Type}` value.
    ///
    func testTypeWith${Type}() {
        XCTAssertEqual((SingleValueContainer(${Type}(${Input}))).type, EncodedType.${Type.lower()})
    }

    ///
    /// Test that `size` returns the proper size after being initialize with a `${Type}` value.
    ///
    func testSizeWith${Type}() {
        XCTAssertEqual((SingleValueContainer(${Type}(${Input}))).size, ${InputSize})
    }

    ///
    /// Test that `value` returns the same `${Type}` value as it was initialized with.
    ///
    func testValueWith${Type}() throws {
        XCTAssertEqual(try (SingleValueContainer(${Type}(${Input}))).value(as: ${Type}.self), ${Type}(${Input}))
    }

    ///
    /// Test that `write` can write to a buffer after being initialize with a `${Type}` value.
    ///
    func testUnsafeMutableRawBufferPointerRoundTripOf${Type}() throws {
        let input = SingleValueContainer(${Type}(${Input}))

        let buffer = UnsafeMutableRawBufferPointer.allocate(count: input.byteCount)
        defer { buffer.deallocate() }

        /// Write the input to our buffer so we can use it to create a new instance.
        input.write(to: buffer)

        /// Create a new instance using the buffer.
        let result = try SingleValueContainer(from: UnsafeRawBufferPointer(buffer))

        /// Validate that the old and new containers are equivalent.
        XCTAssertEqual(result.type, input.type)
        XCTAssertEqual(result.size, input.size)
        XCTAssertEqual(try result.value(as: ${Type}.self), try input.value(as: ${Type}.self))
    }
% if Group == 'Integer':
    
    ///
    /// Test that `self` can be initialized with a `${Type}.min` value and return the same.
    ///
    func testCanStore${Type}Min() throws {
        XCTAssertEqual(try (SingleValueContainer(${Type}.min)).value(as: ${Type}.self), ${Type}.min)
    }

    ///
    /// Test that `self` can be initialized with a `${Type}.max` value and return the same.
    ///
    func testCanStore${Type}Max() throws {
        XCTAssertEqual(try (SingleValueContainer(${Type}.max)).value(as: ${Type}.self), ${Type}.max)
    }
% end
% if Group == 'Float':
    ///
    /// Test that `self` can be initialized with a `${Type}.infinity` value and return the same.
    ///
    func testCanStore${Type}Infinity() throws {
        XCTAssertEqual(try (SingleValueContainer(${Type}.infinity)).value(as: ${Type}.self), ${Type}.infinity)
    }

    ///
    /// Test that `self` can be initialized with a `${Type}.nan` value and return the same.
    ///
    func testCanStore${Type}Nan() throws {
        XCTAssertEqual(try (SingleValueContainer(${Type}.nan)).value(as: ${Type}.self).isNaN, true)
    }
% end
    
    ///
    /// Test that the `description` value is correct after being initialized with a `${Type}` value.
    ///
    func testDescriptionWith${Type}() throws {
        XCTAssertEqual(SingleValueContainer(${Type}(${Input})).description, String(${Input}))
    }

    ///
    /// Test that the `debugDescription` value is correct after being initialized with a `${Type}` value.
    ///
    func testDebugDescriptionWith${Type}() throws {
        XCTAssertEqual(SingleValueContainer(${Type}(${Input})).debugDescription, "SingleValueContainer(type: ${Type}, size: \(${InputSize}), value: \(${Input}))")
    }
% end
    // MARK: - `String` Extended Tests

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode Globes and return the same.
    ///
    func testCanStoreStringUnicodeGlobes() throws {
        XCTAssertEqual(try (SingleValueContainer("🌍🌍🌍🌍🌍🌍🌍🌍🌍")).value(as: String.self), "🌍🌍🌍🌍🌍🌍🌍🌍🌍")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode Flags and return the same.
    ///
    func testCanStoreStringUnicodeFlags() throws {
        XCTAssertEqual(try (SingleValueContainer("🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷")).value(as: String.self), "🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷🇵🇷")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode EPlusAccent and return the same.
    ///
    func testCanStoreStringUnicodeEPlusAccent() throws {
        XCTAssertEqual(try (SingleValueContainer("e\u{0301}")).value(as: String.self), "e\u{0301}")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of Unicode EWithAccent and return the same.
    ///
    func testCanStoreStringUnicodeEWithAccent() throws {
        XCTAssertEqual(try (SingleValueContainer("é")).value(as: String.self), "é")
    }

    ///
    /// Test that `self` can be initialized with a `String` value of a 100k size random String and return the same.
    ///
    func testCanStoreLargeRandomString100k() throws {
        let expected = String.random(length: 102400)

        XCTAssertEqual(try (SingleValueContainer(expected)).value(as: String.self), expected)
    }

    ///
    /// Test that `self` can be initialized with a `String` value of a 1000k size random String and return the same.
    ///
    func testCanStoreLargeRandomString1000k() throws {
        let expected = String.random(length: 1024000)

        XCTAssertEqual(try (SingleValueContainer(expected)).value(as: String.self), expected)
    }
}

///
/// `SingleValueContainerPerformanceTests`
///
class SingleValueContainerPerformanceTests: XCTestCase {
%{
    TestIterations = 5000
}%
%  for (Group, Type, Input, Expected) in variants:
            
    // MARK: - `${Type}` Performance Tests

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a value of `${Type}`.
    ///
    func testInitWith${Type}Performance() {

        self.measure {
            for _ in 1...${TestIterations} {
                let _ = SingleValueContainer(${Type}(${Input}))
            }
        }
    }

    ///
    /// Test the performance of retrieving the `type` of a stored value of type `${Type}`.
    ///
    func testTypeWith${Type}Performance() throws {
        let container = SingleValueContainer(${Type}(${Input}))

        self.measure {
            for _ in 1...${TestIterations} {
                let _ = container.type
            }
        }
    }

    ///
    /// Test the performance of retrieving the `size` of a stored value of type `${Type}`.
    ///
    func testSizeWith${Type}Performance() throws {
        let container = SingleValueContainer(${Type}(${Input}))

        self.measure {
            for _ in 1...${TestIterations} {
                let _ = container.size
            }
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a stored value of type `${Type}`.
    ///
    func testValueWith${Type}Performance() throws {
        let container = SingleValueContainer(${Type}(${Input}))

        self.measure {
            do {
                for _ in 1...${TestIterations} {
                    let _ = try container.value(as: ${Type}.self)
                }
            } catch {
                XCTFail()
            }
        }
    }
% end

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a large string of 100k size.
    ///
    func testInitWithLargeRandomString100kPerformance() throws {
        let value = String.random(length: 102400)

        self.measure {
            let _ = SingleValueContainer(value)
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a large string of 100k size.
    ///
    func testValueWithLargeRandomString100kPerformance() throws {
        let container = SingleValueContainer(String.random(length: 102400))

        self.measure {
            do {
                let _ = try container.value(as: String.self)
            } catch {
                XCTFail()
            }
        }
    }

    ///
    /// Test the performance of initializing an instance a `SingleValueContainer` when storing a large string of 1000k size.
    ///
    func testInitWithLargeRandomString1000kPerformance() throws {
        let value = String.random(length: 1024000)

        self.measure {
            let _ = SingleValueContainer(value)
        }
    }

    ///
    /// Test the performance of retrieving the `value` of a large string of 1000åk size.
    ///
    func testValueWithLargeRandomString1000kPerformance() throws {
        let container = SingleValueContainer(String.random(length: 1024000))

        self.measure {
            do {
                let _ = try container.value(as: String.self)
            } catch {
                XCTFail()
            }
        }
    }
}

///
/// String extension to create a random string of a given size.
///
extension String {

    static func random(length: Int = 1024) -> String {
        let chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        var string = String()
        string.reserveCapacity(length)

        #if os(Linux) || os(FreeBSD)
            ///srandom(UInt32(time(nil)))
        #endif

        for _ in 0..<length {
            #if os(Linux) || os(FreeBSD)
                /// FIXME: Currently (Swift 4) random() produces a string on linux and also crashes when called. To test, we simply produce a string with a sequence of letter 'a'.
                let randomValue = 0 // random() % chars.characters.count
            #else
                let randomValue = arc4random_uniform(UInt32(chars.count))
            #endif

            string.append("\(chars[chars.index(chars.startIndex, offsetBy: Int(randomValue))])")
        }
        return string
    }
}
