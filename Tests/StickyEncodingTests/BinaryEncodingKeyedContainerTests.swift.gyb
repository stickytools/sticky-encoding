///
///  BinaryEncodingKeyedContainerTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/6/17.
///
import XCTest
import TestFixtures

///
/// Note: This file contains public interface tests so do not use @testable.
///
import StickyEncoding

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================
%{
variants = [
    ("Bool",    "Bool", "true", "true"),
    ("Integer", "Int", "32", "32"),
    ("Integer", "Int8", "32", "32"),
    ("Integer", "Int16", "32", "32"),
    ("Integer", "Int32", "32", "32"),
    ("Integer", "Int64", "32", "32"),
    ("Integer", "UInt", "32", "32"),
    ("Integer", "UInt8", "32", "32"),
    ("Integer", "UInt16", "32", "32"),
    ("Integer", "UInt32", "32", "32"),
    ("Integer", "UInt64", "32", "32"),
    ("Float", "Float", "32.0", "32.0"),
    ("Float", "Double", "32.0", "32.0"),
    ("Object", "String", '"Test String"', '"Test String"'),
    ("Object", "CodableType", "CodableType(32)", "CodableType(32)")
]
}%

///
/// `BinaryEncodingKeyedStructuredTypeTests`
///
class BinaryEncodingKeyedContainerTests: XCTestCase {
%  for (Group, TypeName, Input, Expected) in variants:

    // MARK: - `${TypeName}` Tests
% for Type in ["class", "struct"]:

    ///
    /// Test the ability to encode/decode a ${Type} with a `${TypeName}` value using a KeyedContainer.
    ///
    func testEncodeDecodeOf${Type.title()}${TypeName}Keyed() {

        ${Type} InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: ${TypeName}
            init(value: ${TypeName}) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: ${Input})) { (result) in
            XCTAssertEqual(result.value, ${Expected})
        }
    }

    ///
    /// Test the ability to encode/decode a ${Type} with an optional `${TypeName}` value using a KeyedContainer.
    ///
    func testEncodeDecodeOf${Type.title()}Optional${TypeName}Keyed() {

        ${Type} InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: ${TypeName}?
            init(value: ${TypeName}?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: ${Input})) { (result) in
            XCTAssertEqual(result.value, ${Expected})
        }
    }

    ///
    /// Test the ability to encode/decode a ${Type} with an optional `${TypeName}` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOf${Type.title()}Optional${TypeName}WithNilKeyed() {

        ${Type} InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: ${TypeName}?
            init(value: ${TypeName}?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }
% end
% end

    ///
    /// Test the ability to encodeNil/decodeNil using a KeyedContainer
    ///
    func testEncodeDecodeNilWithKeyedContainer() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                if !(try container.decodeNil(forKey: .value)) {
                    self.value = try container.decode(String.self, forKey: .value)
                }
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                if let value = self.value {
                    try container.encode(value, forKey: .value)
                } else {
                    try container.encodeNil(forKey: .value)
                }
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested KeyedContainer from a KeyedContainer.
    ///
    func testEncodeDecodeWithKeyedAndNestedKeyedContainers() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                let nestedContainer = try container.nestedContainer(keyedBy: NestedKeys.self, forKey: .name)

                self.first = try nestedContainer.decode(String.self, forKey: .first)
                self.last  = try nestedContainer.decode(String.self, forKey: .last)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                var nestedContainer = container.nestedContainer(keyedBy: NestedKeys.self, forKey: .name)

                try nestedContainer.encode(self.first, forKey: .first)
                try nestedContainer.encode(self.last,  forKey: .last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested UnkeyedContainer from a KeyedContainer.
    ///
    func testEncodeWithKeyedAndNestedUnkeyedContainers() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                var nestedContainer = try container.nestedUnkeyedContainer(forKey: .name)

                self.first = try nestedContainer.decode(String.self)
                self.last  = try nestedContainer.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                var nestedContainer = container.nestedUnkeyedContainer(forKey: .name)

                try nestedContainer.encode(self.first)
                try nestedContainer.encode(self.last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value calling keyedContainer  multiple times.
    ///
    func testEncodeCallingMultipleKeyedContainers() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                let _ = try decoder.container(keyedBy: CodingKeys.self)

                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.value = try container.decode(String.self, forKey: .value)
            }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.container(keyedBy: CodingKeys.self) /// throw the first away
                let _ = encoder.container(keyedBy: CodingKeys.self) /// And the second

                /// Use the third
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(self.value, forKey: .value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test Value")) { (result) in
            XCTAssertEqual(result.value, "Test Value")
        }
    }

    ///
    /// Test the ability to encode/decode using a KeyedContainer's keyed superEncoder/superDecoder for the super class.
    ///
    func testEncodeDecodeWithSuperEncoderDecoderKeyedContainer() {

        class SuperType: Codable {
            let superValue: Int
            init(superValue: Int) { self.superValue = superValue }

            private enum CodingKeys: CodingKey { case superValue }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.superValue = try container.decode(Int.self, forKey: .superValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(self.superValue, forKey: .superValue)
            }
        }

        class SubType: SuperType {
            let subValue: String
            init(subValue: String, superValue: Int) {
                self.subValue = subValue; super.init(superValue: superValue)
            }

            private enum CodingKeys: CodingKey { case subValue, superClass }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.subValue = try container.decode(String.self, forKey: .subValue)

                try super.init(from: try container.superDecoder(forKey: .superClass))
            }
            override func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(subValue, forKey: .subValue)

                try super.encode(to: container.superEncoder(forKey: .superClass))
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: SubType(subValue: "Test Value", superValue: 32)) { (result) in
            XCTAssertEqual(result.subValue, "Test Value")
            XCTAssertEqual(result.superValue, 32)
        }
    }

    ///
    /// Test the ability to encode/decode using a KeyedContainer's unkeyed superEncoder/superDecoder for the super class.
    ///
    func testEncodeDecodeWithSuperEncoderDecoderUnkeyedContainer() {

        class SuperType: Codable {
            let superValue: Int
            init(superValue: Int) { self.superValue = superValue }

            private enum CodingKeys: CodingKey { case superValue }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.superValue = try container.decode(Int.self, forKey: .superValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(self.superValue, forKey: .superValue)
            }
        }

        class SubType: SuperType {
            let subValue: String
            init(subValue: String, superValue: Int) {
                self.subValue = subValue; super.init(superValue: superValue)
            }

            private enum CodingKeys: CodingKey { case subValue, superClass }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.subValue = try container.decode(String.self, forKey: .subValue)

                try super.init(from: try container.superDecoder())
            }
            override func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(subValue, forKey: .subValue)

                try super.encode(to: container.superEncoder())
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: SubType(subValue: "Test Value", superValue: 32)) { (result) in
            XCTAssertEqual(result.subValue, "Test Value")
            XCTAssertEqual(result.superValue, 32)
        }
    }
}

